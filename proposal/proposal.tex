% Created 2016-12-04 Sun 10:54
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\author{Philip Tham}
\date{\today}
\title{A Lazy to Strict Language Compiler (Tentative)}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.5.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\newpage

\section{Introduction}
\label{sec-1}
\begin{itemize}
\item Lazy language
\item Strict language
\item Compiler to translate code from lazy to strict
\item What can potential problems be?
\item Will this work?
\item Use QuickCheck/Operational Semantics to prove correctness
\end{itemize}


The main difference between lazy and strict programming languages is the steps
of evaluation that their respective compilers take. While a strict language
always fully evaluates all the expressions given as parameters, a lazy language
only evaluates expressions when needed. This means that lazy languages can make
use of infinite data structures and potentially non-terminating function calls.


\section{Related Courses}
\label{sec-2}
\begin{itemize}
\item Programming Language Technology
\item Compiler Construction
\item Models of Computation
\item Introduction to Functional Programming (?)
\item Advanced Functional Programming (?)
\end{itemize}


\section{Literature List}
\label{sec-3}
Books:
\begin{itemize}
\item \url{http://dragonbook.stanford.edu/}
\item \url{https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0}
\item \url{http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/}
\item \url{http://www1.digitalgrammars.com/ipl-book/}
\end{itemize}
% Emacs 24.5.1 (Org mode 8.2.10)
\end{document}

#+AUTHOR:Philip Tham
#+TITLE:A Lazy to Strict Language Compiler (Tentative)
#+OPTIONS: toc:nil

\newpage

* Introduction

The main difference between lazy and strict programming languages is the steps
of evaluation that their respective compilers take. While a strict language
always fully evaluates all the expressions given as parameters, a lazy language
only evaluates expressions when needed. For example, evaluating a logical and
in a lazy language would terminate the function call once a false has been
found, even if the expression contains an infinite chain of function calls.
Evaluating this infinite expression in a strict language would cause an
non-terminating loop.

This project aims to create a compiler that takes code from a lazy programming
language and compiles it in to a strict programming language in order to 
formalize the connection between the two. This compiler will be written in
the programming language Haskell. 
*The source and target languages will be left open for discussion for now.*

\noindent
Possible lazy source languages:
+ CakeML
+ Haskell

\noindent
Possible strict target languages:
+ C#
+ Python

It is necessary to show that the compiler correctly expresses laziness in the
strict language. Operational semantics will be used to prove that the steps of
evaluation are correct. If time allows for it, the compiler will also be tested
for correctness by using the Haskell library QuickCheck.


* Limitations of the Project

+ GHC version?
+ Might not support all types of operations depending on time


* Related Courses
** Programming Language Technology and Compiler Construction
The courses Programming Language Technology and Compiler Construction are
basically the cornerstones of this project, as it is about creating a compiler
that connects two different types of programming languages.

** Models of Computation
Models of Computation discusses different computation models. This includes
programming language of both lazy and strict evaluation processes. For example,
there is the minimalistic (and theoretical) programming language /X/ (Chi) that
models lambda calculus. The language includes weak head normal form (lazy 
evaluation of certain expressions) and full (strict) evaluation.

** Introduction to Functional Programming and Advanced Functional Programming
As this project will be utilizing functional languages (and most likely
programmed in Haskell), these are necessary courses. It is quite possible that
the compilers one has created in Programming Language Technology and Compiler
Construction were written in Haskell. However, as there is no requirement on
functional programming, they should be included here.


* Literature List
+ http://dragonbook.stanford.edu/
+ https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0
+ http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
+ http://www1.digitalgrammars.com/ipl-book/

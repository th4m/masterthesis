#+AUTHOR:Philip Tham
#+TITLE:A Lazy to Strict Language Compiler
#+OPTIONS: toc:nil
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage{fontenc}

\newpage

* Introduction and Project Description

The main difference between lazy and strict programming languages is the steps
of evaluation that their respective compilers take. While a strict language
always fully evaluates all the expressions given as parameters, a lazy language
only evaluates expressions when needed. For example, it is possible to express
infinite data structures, such as lists, in a lazy language. Using these
infinite data structures would not cause non-termination, as long as the
program is not trying to access all of its elements. In Haskell, a lazy
functional language, it is possible to write \texttt{take 5 [1..]} and get the
result \texttt{[1, 2, 3, 4, 5]}, even though \texttt{[1..]} is
an expression of an infinite list. This is because the list is not generated
until it is needed, and only the necessary amount is generated.

This project aims to create a compiler that takes code from a lazy programming
language and compiles it into a strict programming language. The resulting
strict code should have the same semantic evaluation as the given lazy code. 
The purpose of creating such a compiler is to show a formal connection between
lazy and strict evaluation. The compiler will be written in the programming
language Haskell. The source language that the compiler takes as input will be
Haskell and the target language to which the compiler will
output will be CakeML, a strict functional language based on a subset of
Standard ML.

The necessary operational semantics of Haskell will be written as a part of the
project. As the semantics of CakeML is specified in higher-order logic (HOL),
the operational semantics for CakeML will be translated from HOL to Haskell
functions. The semantics of the two languages will then be connected in the
compiler.

To show that the compiler generates semantically equivalent code, this project
will employ the automated testing library QuickCheck for Haskell. QuickCheck
generates random test data according to the provided specification and uses them
to test properties. This means that it is possible to write the operational
semantics of the language as functions in Haskell and test them with QuickCheck.

In summary, the project will be done in two major steps:
+ Create a compiler that translates code from the lazy programming language Haskell to the strict functional language CakeML
+ Test the compiler by writing operational semantics in the form of functions and running them with QuickCheck


* Limitations of the Project

In order to keep the project within a reasonable scale, certain limitations
will be considered:

+ This project will only be using the core language of Haskell. Using all of the programming language would make the scale of the project too large, making it impossible to finish within the given time.
+ The GHC version of this project will be 8.0.1, as it is the latest stable version at the time of writing.


* Related Courses
There are a number of courses at Chalmers that are relevant from this
project's perspective.

** Programming Language Technology and Compiler Construction
The courses Programming Language Technology and Compiler Construction are
basically the cornerstones of this project, as it is about creating a compiler
that connects two different types of programming languages. Programming
Language Technology is the course that introduces the concept of compilers,
and Compiler Construction allows students to create a compiler as a project.
Both courses also encourage writing compilers in Haskell.

** Models of Computation
Models of Computation discusses different computation models. This includes
programming languages of both lazy and strict evaluation processes. For example,
there is the minimalistic (and theoretical) programming language /X/ (Greek 
letter Chi) that models lambda calculus. The language includes weak head normal
form (lazy evaluation of certain expressions) and full (strict) evaluation.

** Introduction to Functional Programming and Advanced Functional Programming
As the languages used in this project are of the functional programming
paradigm, these two courses are essential. The primary programming language 
taught in the two courses on functional programming at Chalmers is Haskell.
The courses go through several basic to advanced techniques of Haskell,
and also have students write small-scale projects in the language.



* Literature List
+ http://dragonbook.stanford.edu/
+ https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-088478-0
+ http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
+ http://www1.digitalgrammars.com/ipl-book/

\chapter{Call-by-need semantics}
With the completion of the compiler, expressions bound as variables are stored
as thunks, delaying their evaluation until they are called. While this means
the compiled code exhibits lazy behaviour, the thunks are evaluated every
time that the variable is called. The optimal behaviour, called
\textit{call-by-need}, is to evaluate the thunks at most once and reuse the
resulting value. This chapter will describe how the compiler was optimised to
use the stateful features of CakeML in order to implement call-by-need
mechanics.

\section{Implementation}
\label{cbn:impl}
With the implementation of the compiler, as described in
Chapter~\ref{chapter:compiler}, expressions bound by variables have been stored
in the environment as thunks and evaluated when called. In order to use
call-by-need mechanics, the compiler was altered to make use of CakeML's
inherent state in order to save thunks, as well as their evaluated value.

Thunks were changed so that instead of containing delayed expressions, they
contained references that point to the location of the delayed expressions in
the state. Two new constructors were introduced under a new type to represent
expressions and values stored in the state: \texttt{RefExp} and \texttt{RefVal}.
Delayed expressions were wrapped in \texttt{Fun} expressions inside the
\texttt{RefExp} constructor, similarly to how they were with the \texttt{Thunk}
constructor before the optimisation. Fully evaluated values were wrapped in the
\texttt{RefVal} constructor without any further modifications, just like with
the \texttt{Val} constructor.

In order to be able to utilise the state, there are three operations that are
vital: \texttt{OpRef}, \texttt{OpDeref}, and \texttt{OpAssign}. These have all
been defined under the \texttt{Op} datatype of the CakeML grammar, which is used
in combination with
the \texttt{App} expression. When evaluated, \texttt{App OpRef [e]} creates a new
entry in the state for the value that \texttt{e} is evaluated to. The reference
is then returned as a location value \texttt{Loc n}. \texttt{App OpDeref [e]}
takes an expression \texttt{e} that is to be evaluated to a reference (e.g. a
variable that contains the reference), and returns the value that was stored in
the state for the given reference. \texttt{App OpAssign [e1, e2]} takes a
reference \texttt{e1} and an expression \texttt{e2}, and changes the value
stored in the state in the location given by \texttt{e1} to the value that
\texttt{e2} is evaluated to. The result of evaluating \texttt{App OpAssign}
is a a constructor expression containing \texttt{Nothing}, which needs to be
kept in mind when using \texttt{OpAssign}.

By using the operations \texttt{OpRef}, \texttt{OpDeref}, and \texttt{OpAssign},
two operations in the compiler were changed. The first change of the compiler
was made to how thunks were generated. This was done in the
\texttt{makeThunk} function, which previously took an expression \texttt{e} and
wrapped it in the \texttt{Thunk} constructor and \texttt{Fun} expression. With
the optimisation, \texttt{makeThunk}
takes \texttt{e} and creates a reference in the state for a \texttt{Fun}
expression wrapped around a \texttt{RefExp} constructor, and finally wraps
everything with a \texttt{Thunk} constructor:
\begin{figure}[H]
\begin{alltt}
  makeThunk e =
    Con (Just (Short "Thunk"))
      [App OpRef
        [Con (Just (Short "RefExp"))
          [Fun "" e]
        ]
      ]
\end{alltt}
\end{figure}
When evaluated, this expression will add the delayed expression to the state and
return a reference to its location. This means that each time a thunk is
created, it will be stored in the state instead of simply being wrapped in a
\texttt{Thunk} constructor and a closure. Similarly, values in the state are
created with a function called \texttt{makeRefVal}:
\begin{figure}[H]
\begin{alltt}
  makeRefVal e = Con (Just (Short "RefVal")) [e]
\end{alltt}
\end{figure}

The second change that was made with the optimisation was how \texttt{force}
behaved. As the \texttt{Thunk} constructor no longer contains a closure, but
instead a reference, the \texttt{Thunk} case of the pattern matching in
\texttt{force} uses the \texttt{OpDeref} operation to get what is stored in
the state for the given reference. The reference can point at either a
\texttt{RefExp} or a \texttt{RefVal} constructor, and must thus be pattern
matched. When a \texttt{RefVal} is caught in the pattern matching, the contained
value is simply returned as it is. For the \texttt{RefExp} case, the contained
value is a delayed expression in a closure and must thus be forced.
The \texttt{RefExp} that the reference was pointing to is then changed with an
\texttt{OpAssign} operation to a \texttt{RefVal} of the value that the
\texttt{force} yielded. After the assignment, the evaluated value is returned.

\begin{figure}[H]
\begin{alltt}
  force :: Exp -> Exp
  force e =
    App OpApp [LetRec [("force", "exp"
                       , Mat (Var (Short "exp"))
                         [(PCon (Just (Short "Thunk")) [PVar "TPtr"]
                          ,refMat (App OpDeref [Var (Short "TPtr")]))
                         ,(PCon (Just (Short "Val")) [PVar "Val"]
                          , Var (Short "Val"))]
                       )] (Var (Short "force"))
              , e]

  refMat :: Exp -> Exp
  refMat e =
    Mat (e)
    [(PCon (Just (Short "RefVal")) [PVar "RefV"]
     ,Var (Short "RefV"))
    ,(PCon (Just (Short "RefExp")) [PVar "RefE"]
     ,Let Nothing (App OpAssign [Var (Short "TPtr"), makeRefVal sol])
       (getVal (App OpDeref [Var (Short "TPtr")])))
    ]
    where sol = App OpApp [Var (Short "force"),
                           App OpApp [Var (Short "RefE")
                                     ,Literal (IntLit 0)]]
          getVal e' = Mat e'
                      [(refValPat [PVar "RVal"]
                       ,Var (Short "RVal"))]
\end{alltt}
\end{figure}
With these re-definitions, the \texttt{compile} function does not need any
changes and can be used as before the optimisation.

\section{Testing call-by-need}
The testing of the call-by-need mechanics mainly consisted of running the tests
that were used in the creation of the \texttt{compile} function, by using
\texttt{compareEval} described in Section~\ref{compiler:test}. However, with
the optimisation, the state is used for creating thunks. This means that
evaluating certain compiled expressions causes the state to grow to a larger
size than when evaluating the same expressions without compiling them. Thus, the
state was omitted in the comparison of this testing phase, testing only the
result of the evaluations.

Another factor that needed testing was how the thunks were changed in the state.
As stated in Section~\ref{cbn:impl}, when thunks are created, they are created
as delayed evaluations of expressions, represented as \texttt{RefExp}. When they
are forced, they are changed to become values, represented as \texttt{RefVal}.
In order to test that evaluated thunks indeed were changed to \texttt{RefVal}
values, expressions that created and called thunks were evaluated with the
\texttt{efc} function described in Section~\ref{compiler:test}. Similarly,
thunks that were not forced were checked to see if they remained as
\texttt{RefExp} values after evaluation. As evaluation yields both the result
and the state, the thunk references could be investigated to see if they were
\texttt{RefExp} or \texttt{RefVal} constructors.

Call-by-need was also tested by using thunks that require a noticeable amount of
time to evaluate. One method was to create a list of a replicated expression:
\begin{figure}[H]
\begin{alltt}
  cakeReplicate =
    LetRec [("repeat", "elem",
              Fun "n" $
              If (App Equality [Var (Short "n"), Literal (IntLit 0)])
               (Con (Just (Short "nil")) [])
               (Con (Just (Short "::"))
                [Var (Short "elem"),
                 App OpApp [App OpApp [Var (Short "repeat"),
                                       Var (Short "elem")],
                            decr]])
            )] (Var (Short "repeat"))
\end{alltt}
\end{figure}
This function \texttt{cakeReplicate} was used to create a list with an
expression that counts down to 0 and returns the string literal "OK":
\begin{figure}[H]
\begin{alltt}
  stopAtZero =
    LetRec [("stopAtZero", "n",
             If (App Equality [Var (Short "n"), Literal (IntLit 0)])
              (Literal (StrLit "OK"))
              (App OpApp [Var (Short "stopAtZero"), decr])
            )] (Var (Short "stopAtZero"))
\end{alltt}
\end{figure}
Replication of \texttt{stopAtZero} was tested with two versions of the compiler:
(1) with the call-by-need optimisation and (2) without call-by-need. For a list
of \texttt{stopAtZero} that counted from 100, (1) printed the whole list much
faster than (2), which required a noteworthy amount of evaluation time for each
list element. This result showed that call-by-need in (1) was indeed working as
intended: each thunk's suspended expression is evaluated once and replaced with
a value, which is used in future calls, reducing the total evaluation time.

When the results of this testing phase were positive, the implementation of the
call-by-need semantics was deemed to be finished. This would also mark the
completion of the compiler as a whole, meaning that all the coding had now been
finished.

%% TODO: tested the compiler with large lists.
%% Lazy lists showed better results for certain operations (take).
%% Repeating a saved value in a list has almost no difference in execution time
%%   compared to strict semantics.

\section{Discussion}
Alternative structures were considered for the constructors used to implement
call-by-need. One of these was to add a constructor under the same type
identifier as the \texttt{Val} and \texttt{Thunk} constructors that contained
a reference. The expression or value that the reference pointed at would then be
forced and assigned to the reference. A problem with this approach would be
that by using the same type, there is no clear distinction between references
and other expressions. Suspended evaluations could be created and exist on the
same level as the references to the suspensions. The structure that was used in
the end creates a border between different types. By having \texttt{RefExp} and
\texttt{RefVal} represent all thunks in the state, and \texttt{Val} and
\texttt{Thunk} represent values and references to thunks,
it is clear where everything belongs. This
distinction also allows separate pattern matching for the contents of the
references that \texttt{Thunk} points at, making it easier to know when to
make an assignment of a new value to a reference or to just return the stored
value.

Manually written unit tests proved to be lacking, as it required consideration \placement{Should this paragraph be here?}
of all cases where the implementation of the compilation or evaluation might be
bugged. As a compiler handles construction of a program, it can be difficult to
create a very specific combination of expressions to create a certain bug.
For example, a bug concerning the state was discovered at the testing stage
of call-by-need. The bug caused the wrong state to be returned and occurred in
the evaluation of the \texttt{App OpApp} expression. This means that to catch
this bug, a \texttt{Fun x e} expression needed to be created (and called) with
\texttt{e} being an expression that causes some change to the state. Unit
testing can be replaced with property-based testing. Haskell has the
property-based testing library QuickCheck~\cite{Introduc44:online}. By writing
properties for tests, QuickCheck generates and runs tests automatically,
allowing for extensive testing. Unfortunately, exploring the usage of QuickCheck
for this project was not possible because of time constraints, as property-based
testing for compilers might be enough workload for a project of its own.




%%TODO: delayed expressions -> delayed evaluations?

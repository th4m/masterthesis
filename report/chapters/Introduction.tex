\chapter{Introduction}
Lazy programming is a style of programming that makes use of lazy evaluation.
Evaluating a program lazily means that expressions that are bound by variables
are not evaluated until their results are needed in another part of the
program~\cite{Lazyeval6:online}. This is often put in contrast with another
evaluation style called strict evaluation, which always evaluates expressions
as they are to be bound by variables. 

The main difference between lazy and strict programming languages is the steps
of evaluation that their respective semantics take. With strict semantics,
expressions are evaluated when they are created, while with lazy semantics,
expressions are evaluated when they are needed~\cite{ThunkHas27:online}.
This means that in lazy semantics
you can give a function an argument that cannot be terminated, and as long as
that argument is never used, the function itself can still terminate normally.

It has been argued that lazy programming (and functional programming in general)
brings improvement to software development in the form of
modularity~\cite{Hu1989}~\cite{Hu2015}. Laziness allows the creation of certain
types of programs that cannot be executed by using strict semantics.
For example, the \textit{Fibonacci numbers} is an infinite sequence of numbers
where each number is equal to the sum of the two previous numbers. [CITE?]
Defining the Fibonacci numbers as an expression with strict semantics would
cause the execution to never terminate, as it is required for the function to be
fully evaluated when assigning it to a variable. In a lazy context, however,
the expression that defines the Fibonacci numbers would simply not be evaluted
until it is actually needed, meaning that simply assigning it to a variable
would not cause the program to not terminate.

While lazy evaluation can be seen as very beneficial, there are cases where it
would not be optimal to evaluate lazily. For example, programs where there are
no superfluous expressions would not have much use of lazy evaluation. When it
is known that all expressions bound by variables will be used, it is a fact that
they will all need to be evaluated. The underlying reason why it would be worse
to apply lazy evaluation, rather than strict evaluation, is how lazy evaluation
delays the evaluation of expressions. The act of delaying evaluation creates
an overhead in both memory and processing time.
In cases where there are no superfluous expressions in the code, using lazy
semantics can actually cause slower evaluation time when compared to
strict semantics. Despite this potential drawback, laziness can be a desirable
feature in many use cases. 

\section{An Example of Lazy vs Strict Evaluation}
\label{intro:Example}
The difference between strict and lazy evaluation has now been described.
In order to gain a better picture of the benefits of using lazy evaluation,
this section will illustrate and discuss an example of evaluation of an
expression.

A useful feature in lazy programming languages is
infinite data structures, such as infinite lists. Using
these infinite data structures will not cause non-termination, as long as the
program is not trying to access all of its elements. In Haskell, a lazy
functional language, it is possible to write \texttt{take 5 [1..]} and get the
result \texttt{[1, 2, 3, 4, 5]}, even though \texttt{[1..]} is
an expression of an infinite list. This is because the list is not generated
until it is needed, and only the necessary number of elements are generated.

Below is an example of how \texttt{take} could be implemented. The function
takes an integer (for the number of elements to take) and a list as arguments.
This assumes that there is a data type definition for \texttt{List} with two
constructors:
\begin{itemize}
  \item \texttt{Cons (a, List as)} for when there is an element \texttt{a} and the rest of the list \texttt{as}
  \item \texttt{Nil} for the empty list
\end{itemize}

\begin{figure}[H]
\begin{alltt}
take n list =
  if n == 0 then
    Nil
  else
    case list of
      Cons (a, as) -> Cons (a, (takeHs n-1 as))
      Nil          -> Nil
\end{alltt}
\end{figure}

\noindent The function can be written like this (with some syntax differences)
for any language, but the semantics
changes the strategy of evaluation. E.g. a strict language is likely to evaluate
all of \texttt{list} when pattern matching, while a lazy language is likely to
evaluate only part of the list as much as needed. 

\section{Project Description}
The goal of this project is to create a compiler that takes code from a strict
programming language and compiles it to allow for a lazy evaluation style. The
resulting code should have the same user-observable evaluation as the given
strict code. The purpose of creating such a compiler is to explore the formal
connection between lazy and strict evaluation. The compiler will be written in
the programming language Haskell. The source language for the compiler will be
CakeML (which has strict semantics ) and the target language to which the
compiler will output will be CakeML, but with support for lazy evaluation. This
means that the semantics to express laziness will be defined as part of this
project and used as a base to implement the compiler.

Internally, the compiler will take a
CakeML function with lazy semantics and translate it to one
or more strict CakeML functions in order to get a semantically equivalent
evaluation. When it comes to handling laziness, lazy functions will be
translated to explicit thunk values~\cite{Ingerman:1961:TWC:366062.366084} in
CakeML. Thunks are expressions that have yet to be evaluated. Thunk values are
not primitive in CakeML. Our compiler will create code that
implements the thunk values in CakeML. The compiler will target the stateful
features of CakeML to avoid repeated evaluation of the same thunk values.

The operational semantics of lazy CakeML will be written as a part of the
project. As the semantics of CakeML is specified in higher-order logic
(HOL)~\cite{HOLInter57:online},
the operational semantics for CakeML will be translated from HOL to Haskell
functions. The compiler will then connect the lazy and strict semantics.

Tests will be written to show that the compiler generates semantically
equivalent code. This project will employ manual unit testing to test
expressions and steps of evaluation.

In summary, the project will consist of three major parts that will be developed
in parallel:
\begin{itemize}
 \item Writing lazy semantics for the programming language CakeML
 \item Creating a compiler that translates the lazy semantics to the original strict semantics of CakeML
 \item Testing the compiler by writing operational semantics in the form of functions and running unit tests.
\end{itemize}
